<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Survivor Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.70.0/phaser.min.js"></script>
    <style>
        body { margin: 0; padding: 0; background: #111; }
        #game { width: 100vw; height: 100vh; }
        #hud {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-family: Arial, sans-serif;
            text-align: center;
            pointer-events: none;
            z-index: 100;
            text-shadow: 2px 2px 2px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <div id="hud"></div>
    <div id="game"></div>

<script>
// Game constants
const CONSTANTS = {
    PLAYER: {
        SPEED: 160,
        HEALTH: 100,
        SIZE: 20,
        SHOOT_DELAY: 400
    },
    ENEMY: {
        BASIC: {
            SPEED: 100,
            HEALTH: 30,
            DAMAGE: 10,
            COLOR: 0xff0000
        },
        FAST: {
            SPEED: 150,
            HEALTH: 20,
            DAMAGE: 5,
            COLOR: 0xff6600
        },
        TANK: {
            SPEED: 60,
            HEALTH: 100,
            DAMAGE: 20,
            COLOR: 0x990000
        }
    },
    COLORS: {
        PLAYER: 0x00ff00,
        PROJECTILE: 0xffff00,
        XP_ORB: 0x0066ff
    },
    GAME: {
        SPAWN_RATE: 1000,
        MAX_ENEMIES: 50,
        DIFFICULTY_INCREASE_RATE: 10000
    }
};

class MainScene extends Phaser.Scene {
    constructor() {
        super({ key: 'MainScene' });
    }

    preload() {
        const graphics = this.add.graphics();
        
        // Player
        graphics.fillStyle(CONSTANTS.COLORS.PLAYER);
        graphics.fillCircle(20, 20, CONSTANTS.PLAYER.SIZE);
        graphics.generateTexture('player', 40, 40);
        graphics.clear();

        // Enemy types
        Object.entries(CONSTANTS.ENEMY).forEach(([type, data]) => {
            graphics.fillStyle(data.COLOR);
            graphics.fillCircle(15, 15, 15);
            graphics.generateTexture(`enemy_${type.toLowerCase()}`, 30, 30);
            graphics.clear();
        });

        // Projectile
        graphics.fillStyle(CONSTANTS.COLORS.PROJECTILE);
        graphics.fillCircle(5, 5, 5);
        graphics.generateTexture('projectile', 10, 10);
        graphics.clear();

        // XP Orb
        graphics.fillStyle(CONSTANTS.COLORS.XP_ORB);
        graphics.fillCircle(5, 5, 5);
        graphics.generateTexture('xp_orb', 10, 10);
        graphics.clear();
    }

    create() {
        // Game state
        this.score = 0;
        this.level = 1;
        this.experience = 0;
        this.nextLevelExp = 100;
        
        // Initialize player
        this.player = this.physics.add.sprite(400, 300, 'player');
        this.player.health = CONSTANTS.PLAYER.HEALTH;
        this.player.maxHealth = CONSTANTS.PLAYER.HEALTH;
        this.player.damage = 10;
        this.player.setCollideWorldBounds(true);
        
        // Setup controls
        this.cursors = this.input.keyboard.createCursorKeys();
        this.wasd = this.input.keyboard.addKeys({
            W: Phaser.Input.Keyboard.KeyCodes.W,
            A: Phaser.Input.Keyboard.KeyCodes.A,
            S: Phaser.Input.Keyboard.KeyCodes.S,
            D: Phaser.Input.Keyboard.KeyCodes.D
        });

        // Mobile controls
        if (this.sys.game.device.input.touch) {
            this.input.addPointer(2);
            this.input.on('pointerdown', (pointer) => {
                this.moveToPointer(pointer);
            });
            this.input.on('pointermove', (pointer) => {
                if (pointer.isDown) {
                    this.moveToPointer(pointer);
                }
            });
        }

        // Setup groups
        this.enemies = this.physics.add.group();
        this.projectiles = this.physics.add.group();
        this.xpOrbs = this.physics.add.group();

        // Spawn enemies periodically
        this.spawnTimer = this.time.addEvent({
            delay: CONSTANTS.GAME.SPAWN_RATE,
            callback: this.spawnEnemy,
            callbackScope: this,
            loop: true
        });

        // Increase difficulty over time
        this.time.addEvent({
            delay: CONSTANTS.GAME.DIFFICULTY_INCREASE_RATE,
            callback: this.increaseDifficulty,
            callbackScope: this,
            loop: true
        });

        // Setup collisions
        this.physics.add.overlap(this.projectiles, this.enemies, this.hitEnemy, null, this);
        this.physics.add.overlap(this.player, this.enemies, this.damagePlayer, null, this);
        this.physics.add.overlap(this.player, this.xpOrbs, this.collectXP, null, this);

        // Camera follow player
        this.cameras.main.startFollow(this.player, true, 0.1, 0.1);
        
        // World bounds
        this.physics.world.setBounds(-1000, -1000, 2000, 2000);

        // Update HUD
        this.updateHUD();
    }

    update() {
        if (this.player.health <= 0) return;
        
        this.handlePlayerMovement();
        this.handleShooting();
        
        // Update enemies
        this.enemies.getChildren().forEach(enemy => {
            // Move towards player
            const angle = Phaser.Math.Angle.Between(
                enemy.x, enemy.y,
                this.player.x, this.player.y
            );
            const velocity = this.physics.velocityFromRotation(
                angle, 
                enemy.getData('speed')
            );
            enemy.setVelocity(velocity.x, velocity.y);
            
            // Update health bar position
            if (enemy.healthBar) {
                enemy.healthBar.x = enemy.x;
                enemy.healthBar.y = enemy.y - 20;
                enemy.healthBar.width = 30 * (enemy.getData('health') / enemy.getData('maxHealth'));
            }
        });
        
        // Attract XP orbs to player
        this.xpOrbs.getChildren().forEach(orb => {
            const distance = Phaser.Math.Distance.Between(
                orb.x, orb.y,
                this.player.x, this.player.y
            );
            if (distance < 100) {
                const angle = Phaser.Math.Angle.Between(
                    orb.x, orb.y,
                    this.player.x, this.player.y
                );
                const speed = 200 * (1 - distance / 100);
                const velocity = this.physics.velocityFromRotation(angle, speed);
                orb.setVelocity(velocity.x, velocity.y);
            }
        });
    }

    handlePlayerMovement() {
        let vx = 0;
        let vy = 0;

        if (this.cursors.left.isDown || this.wasd.A.isDown) vx -= 1;
        if (this.cursors.right.isDown || this.wasd.D.isDown) vx += 1;
        if (this.cursors.up.isDown || this.wasd.W.isDown) vy -= 1;
        if (this.cursors.down.isDown || this.wasd.S.isDown) vy += 1;

        if (vx !== 0 || vy !== 0) {
            const norm = Math.sqrt(vx * vx + vy * vy);
            vx = (vx / norm) * CONSTANTS.PLAYER.SPEED;
            vy = (vy / norm) * CONSTANTS.PLAYER.SPEED;
        }

        this.player.setVelocity(vx, vy);
    }

    handleShooting() {
        if (this.time.now > (this.lastShot || 0) + CONSTANTS.PLAYER.SHOOT_DELAY) {
            const closestEnemy = this.findClosestEnemy();
            if (closestEnemy) {
                this.shoot(closestEnemy);
                this.lastShot = this.time.now;
            }
        }
    }

    moveToPointer(pointer) {
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            pointer.worldX, pointer.worldY
        );
        const velocity = this.physics.velocityFromRotation(angle, CONSTANTS.PLAYER.SPEED);
        this.player.setVelocity(velocity.x, velocity.y);
    }

    shoot(target) {
        const projectile = this.projectiles.create(this.player.x, this.player.y, 'projectile');
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            target.x, target.y
        );
        const velocity = this.physics.velocityFromRotation(angle, 300);
        projectile.setVelocity(velocity.x, velocity.y);

        this.time.delayedCall(2000, () => {
            if (projectile.active) {
                projectile.destroy();
            }
        });
    }

    spawnEnemy() {
        if (this.enemies.getLength() >= CONSTANTS.GAME.MAX_ENEMIES) {
            return;
        }

        const distance = 400;
        const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);
        const x = this.player.x + Math.cos(angle) * distance;
        const y = this.player.y + Math.sin(angle) * distance;
        
        let enemyType;
        const roll = Math.random();
        if (roll < 0.1 && this.level >= 5) {
            enemyType = 'TANK';
        } else if (roll < 0.4 && this.level >= 3) {
            enemyType = 'FAST';
        } else {
            enemyType = 'BASIC';
        }
        
        const enemyConfig = CONSTANTS.ENEMY[enemyType];
        const enemy = this.enemies.create(x, y, `enemy_${enemyType.toLowerCase()}`);
        enemy.setData({
            type: enemyType,
            health: enemyConfig.HEALTH,
            maxHealth: enemyConfig.HEALTH,
            speed: enemyConfig.SPEED,
            damage: enemyConfig.DAMAGE
        });
        
        enemy.healthBar = this.add.rectangle(
            enemy.x,
            enemy.y - 20,
            30,
            4,
            0x00ff00
        );
        
        return enemy;
    }

    findClosestEnemy() {
        let closest = null;
        let minDistance = Infinity;

        this.enemies.getChildren().forEach(enemy => {
            const distance = Phaser.Math.Distance.Between(
                this.player.x, this.player.y,
                enemy.x, enemy.y
            );
            if (distance < minDistance) {
                minDistance = distance;
                closest = enemy;
            }
        });

        return closest;
    }

    hitEnemy(projectile, enemy) {
        if (projectile.active) projectile.destroy();
        
        const damage = this.player.damage;
        enemy.setData('health', enemy.getData('health') - damage);
        
        // Visual feedback
        enemy.setTint(0xff0000);
        this.time.delayedCall(100, () => {
            if (enemy.active) enemy.clearTint();
        });
        
        if (enemy.getData('health') <= 0) {
            const xpValue = enemy.getData('type') === 'TANK' ? 20 :
                          enemy.getData('type') === 'FAST' ? 10 : 5;
            
            const xpOrb = this.xpOrbs.create(enemy.x, enemy.y, 'xp_orb');
            xpOrb.setData('value', xpValue);
            
            if (enemy.healthBar) enemy.healthBar.destroy();
            enemy.destroy();
            
            this.score += xpValue;
        }
    }

    damagePlayer(player, enemy) {
        const damage = enemy.getData('damage');
        player.health -= damage;
        
        // Visual feedback
        player.setTint(0xff0000);
        this.time.delayedCall(100, () => {
            if (player.active) player.clearTint();
        });
        
        if (enemy.healthBar) enemy.healthBar.destroy();
        enemy.destroy();
        
        this.updateHUD();
        
        if (player.health <= 0) {
            this.gameOver();
        }
    }

    collectXP(player, xpOrb) {
        const value = xpOrb.getData('value');
        this.experience += value;
        xpOrb.destroy();
        
        if (this.experience >= this.nextLevelExp) {
            this.levelUp();
        }
        
        this.updateHUD();
    }

    levelUp() {
        this.level++;
        this.experience -= this.nextLevelExp;
        this.nextLevelExp = Math.floor(this.nextLevelExp * 1.2);
        
        // Increase player stats
        this.player.damage += 2;
        this.player.maxHealth += 10;
        this.player.health = this.player.maxHealth;
        
        // Visual feedback
        this.add.text(this.player.x, this.player.y - 50, 'LEVEL UP!', {
            fontSize: '24px',
            fill: '#ffff00'
        }).setOrigin(0.5).setDepth(1);
    }

    gameOver() {
        this.add.text(400, 300, 'GAME OVER\nClick to restart', {
            fontSize: '48px',
            fill: '#ff0000',
            align: 'center'
        }).setOrigin(0.5).setScrollFactor(0);
        
        this.input.once('pointerdown', () => {
            this.scene.restart();
        });
    }

    increaseDifficulty() {
        Object.values(CONSTANTS.ENEMY).forEach(type => {
            type.HEALTH *= 1.1;
            type.DAMAGE *= 1.05;
        });
        if (this.spawnTimer.delay > 200) {
            this.spawnTimer.delay *= 0.9;
        }
    }

    updateHUD() {
        document.getElementById('hud').innerHTML = `
            Level: ${this.level} | Score: ${this.score}<br>
            Health: ${Math.ceil(this.player.health)}/${this.player.maxHealth}<br>
            Experience: ${this.experience}/${this.nextLevelExp}<br>
            Damage: ${this.player.damage}
        `;
    }
}

// Game configuration
const config = {
    type: Phaser.AUTO,
    parent: 'game',
    width: window.innerWidth,
    height: window.innerHeight,
    physics: {
        default: 'arcade',
        arcade: {
            debug: false
        }
    },
    scene: MainScene,
    scale: {
        mode: Phaser.Scale.RESIZE,
        autoCenter: Phaser.Scale.CENTER_BOTH
    }
};

// Start the game
const game = new Phaser.Game(config);

// Handle window resizing
window.addEventListener('resize', () => {
    game.scale.resize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>