<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Survivor Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.70.0/phaser.min.js"></script>
    <style>
        body { margin: 0; padding: 0; background: #111; }
        #game { width: 100vw; height: 100vh; }
        #hud {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-family: Arial, sans-serif;
            text-align: center;
            pointer-events: none;
            z-index: 100;
            text-shadow: 2px 2px 2px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <div id="hud"></div>
    <div id="game"></div>

<script>
// Game constants
// Game State Management
const GameState = {
    RUNNING: 'running',
    PAUSED: 'paused',
    LEVELUP: 'levelup',
    GAMEOVER: 'gameover'
};

// Detailed game constants
const CONSTANTS = {
    PLAYER: {
        SPEED: 160,
        HEALTH: 100,
        SIZE: 20,
        SHOOT_DELAY: 400
    },
    ENEMY: {
        BASIC: {
            SPEED: 100,
            HEALTH: 30,
            DAMAGE: 10,
            COLOR: 0xff0000,
            XP_VALUE: 5,
            DESCRIPTION: "Basic enemy: Balanced stats",
            ABILITIES: []
        },
        FAST: {
            SPEED: 150,
            HEALTH: 20,
            DAMAGE: 5,
            COLOR: 0xff6600,
            XP_VALUE: 8,
            DESCRIPTION: "Fast enemy: High speed, low health",
            ABILITIES: ['dash']
        },
        TANK: {
            SPEED: 60,
            HEALTH: 100,
            DAMAGE: 20,
            COLOR: 0x990000,
            XP_VALUE: 15,
            DESCRIPTION: "Tank enemy: High health and damage, slow speed",
            ABILITIES: ['resistance']
        },
        RANGED: {
            SPEED: 80,
            HEALTH: 40,
            DAMAGE: 15,
            COLOR: 0x9900ff,
            XP_VALUE: 12,
            DESCRIPTION: "Ranged enemy: Attacks from distance",
            ABILITIES: ['shoot']
        },
        SPAWNER: {
            SPEED: 40,
            HEALTH: 80,
            DAMAGE: 5,
            COLOR: 0x00ff99,
            XP_VALUE: 20,
            DESCRIPTION: "Spawner: Creates smaller enemies",
            ABILITIES: ['spawn']
        },
        BOSS: {
            SPEED: 70,
            HEALTH: 500,
            DAMAGE: 40,
            COLOR: 0xff0066,
            XP_VALUE: 100,
            DESCRIPTION: "Boss: Extremely powerful enemy with multiple abilities",
            ABILITIES: ['dash', 'shoot', 'spawn', 'resistance']
        },
        MINION: {
            SPEED: 120,
            HEALTH: 10,
            DAMAGE: 3,
            COLOR: 0x66ff66,
            XP_VALUE: 2,
            DESCRIPTION: "Minion: Weak but spawned in groups",
            ABILITIES: []
        }
        BASIC: {
            SPEED: 100,
            HEALTH: 30,
            DAMAGE: 10,
            COLOR: 0xff0000
        },
        FAST: {
            SPEED: 150,
            HEALTH: 20,
            DAMAGE: 5,
            COLOR: 0xff6600
        },
        TANK: {
            SPEED: 60,
            HEALTH: 100,
            DAMAGE: 20,
            COLOR: 0x990000
        }
    },
    COLORS: {
        PLAYER: 0x00ff00,
        PROJECTILE: 0xffff00,
        XP_ORB: 0x0066ff
    },
    UPGRADES: {
        DAMAGE: {
            name: "Increased Damage",
            description: "Increase attack damage by 20%",
            maxLevel: 10,
            effect: (player) => {
                player.damage *= 1.2;
            }
        },
        HEALTH: {
            name: "Maximum Health",
            description: "Increase max health by 25",
            maxLevel: 10,
            effect: (player) => {
                player.maxHealth += 25;
                player.health = player.maxHealth;
            }
        },
        SPEED: {
            name: "Movement Speed",
            description: "Increase movement speed by 10%",
            maxLevel: 5,
            effect: (player) => {
                player.speed *= 1.1;
            }
        },
        PROJECTILES: {
            name: "Multiple Projectiles",
            description: "Fire an additional projectile",
            maxLevel: 4,
            effect: (player) => {
                player.projectileCount = (player.projectileCount || 1) + 1;
            }
        },
        RANGE: {
            name: "Attack Range",
            description: "Increase projectile range by 20%",
            maxLevel: 5,
            effect: (player) => {
                player.range *= 1.2;
            }
        },
        COOLDOWN: {
            name: "Attack Speed",
            description: "Reduce attack cooldown by 10%",
            maxLevel: 8,
            effect: (player) => {
                player.shootDelay *= 0.9;
            }
        },
        MAGNET: {
            name: "Item Magnet",
            description: "Increase XP collection range by 25%",
            maxLevel: 5,
            effect: (player) => {
                player.magnetRange *= 1.25;
            }
        }
    },
    GAME: {
        SPAWN_RATE: 1000,
        MAX_ENEMIES: 50,
        DIFFICULTY_INCREASE_RATE: 10000
    }
};

class MainScene extends Phaser.Scene {
    constructor() {
        super({ key: 'MainScene' });
        this.gameState = GameState.RUNNING;
        this.upgradeLevels = {};
        Object.keys(CONSTANTS.UPGRADES).forEach(upgrade => {
            this.upgradeLevels[upgrade] = 0;
        });
    }

    preload() {
        const graphics = this.add.graphics();
        
        // Player
        graphics.fillStyle(CONSTANTS.COLORS.PLAYER);
        graphics.fillCircle(20, 20, CONSTANTS.PLAYER.SIZE);
        graphics.generateTexture('player', 40, 40);
        graphics.clear();

        // Enemy types
        Object.entries(CONSTANTS.ENEMY).forEach(([type, data]) => {
            graphics.fillStyle(data.COLOR);
            graphics.fillCircle(15, 15, 15);
            graphics.generateTexture(`enemy_${type.toLowerCase()}`, 30, 30);
            graphics.clear();
        });

        // Projectile
        graphics.fillStyle(CONSTANTS.COLORS.PROJECTILE);
        graphics.fillCircle(5, 5, 5);
        graphics.generateTexture('projectile', 10, 10);
        graphics.clear();

        // XP Orb
        graphics.fillStyle(CONSTANTS.COLORS.XP_ORB);
        graphics.fillCircle(5, 5, 5);
        graphics.generateTexture('xp_orb', 10, 10);
        graphics.clear();
    }

    create() {
        // Initialize UI elements
        this.createUI();
        
        // Initialize game state
        // Game state
        this.score = 0;
        this.level = 1;
        this.experience = 0;
        this.nextLevelExp = 100;
        
        // Initialize player
        this.player = this.physics.add.sprite(400, 300, 'player');
        this.player.health = CONSTANTS.PLAYER.HEALTH;
        this.player.maxHealth = CONSTANTS.PLAYER.HEALTH;
        this.player.damage = 10;
        this.player.setCollideWorldBounds(true);
        
        // Setup controls
        this.cursors = this.input.keyboard.createCursorKeys();
        this.wasd = this.input.keyboard.addKeys({
            W: Phaser.Input.Keyboard.KeyCodes.W,
            A: Phaser.Input.Keyboard.KeyCodes.A,
            S: Phaser.Input.Keyboard.KeyCodes.S,
            D: Phaser.Input.Keyboard.KeyCodes.D
        });

        // Mobile controls
        if (this.sys.game.device.input.touch) {
            this.input.addPointer(2);
            this.input.on('pointerdown', (pointer) => {
                this.moveToPointer(pointer);
            });
            this.input.on('pointermove', (pointer) => {
                if (pointer.isDown) {
                    this.moveToPointer(pointer);
                }
            });
        }

        // Setup groups
        this.enemies = this.physics.add.group();
        this.projectiles = this.physics.add.group();
        this.xpOrbs = this.physics.add.group();

        // Spawn enemies periodically
        this.spawnTimer = this.time.addEvent({
            delay: CONSTANTS.GAME.SPAWN_RATE,
            callback: this.spawnEnemy,
            callbackScope: this,
            loop: true
        });

        // Increase difficulty over time
        this.time.addEvent({
            delay: CONSTANTS.GAME.DIFFICULTY_INCREASE_RATE,
            callback: this.increaseDifficulty,
            callbackScope: this,
            loop: true
        });

        // Setup collisions
        this.physics.add.overlap(this.projectiles, this.enemies, this.hitEnemy, null, this);
        this.physics.add.overlap(this.player, this.enemies, this.damagePlayer, null, this);
        this.physics.add.overlap(this.player, this.xpOrbs, this.collectXP, null, this);

        // Camera follow player
        this.cameras.main.startFollow(this.player, true, 0.1, 0.1);
        
        // World bounds
        this.physics.world.setBounds(-1000, -1000, 2000, 2000);

        // Update HUD
        this.updateHUD();
    }

    createUI() {
        // Create upgrade menu
        this.upgradeMenu = document.createElement('div');
        this.upgradeMenu.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            color: white;
            display: none;
            z-index: 1000;
        `;
        document.body.appendChild(this.upgradeMenu);

        // Create tooltip
        this.tooltip = document.createElement('div');
        this.tooltip.style.cssText = `
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            padding: 10px;
            border-radius: 5px;
            color: white;
            pointer-events: none;
            z-index: 1001;
            display: none;
        `;
        document.body.appendChild(this.tooltip);
    }

    update() {
        if (this.gameState !== GameState.RUNNING) return;
        
        this.handlePlayerMovement();
        this.handleShooting();
        
        // Update enemies
        this.enemies.getChildren().forEach(enemy => {
            // Move towards player
            const angle = Phaser.Math.Angle.Between(
                enemy.x, enemy.y,
                this.player.x, this.player.y
            );
            const velocity = this.physics.velocityFromRotation(
                angle, 
                enemy.getData('speed')
            );
            enemy.setVelocity(velocity.x, velocity.y);
            
            // Update health bar position
            if (enemy.healthBar) {
                enemy.healthBar.x = enemy.x;
                enemy.healthBar.y = enemy.y - 20;
                enemy.healthBar.width = 30 * (enemy.getData('health') / enemy.getData('maxHealth'));
            }
        });
        
        // Attract XP orbs to player
        this.xpOrbs.getChildren().forEach(orb => {
            const distance = Phaser.Math.Distance.Between(
                orb.x, orb.y,
                this.player.x, this.player.y
            );
            if (distance < 100) {
                const angle = Phaser.Math.Angle.Between(
                    orb.x, orb.y,
                    this.player.x, this.player.y
                );
                const speed = 200 * (1 - distance / 100);
                const velocity = this.physics.velocityFromRotation(angle, speed);
                orb.setVelocity(velocity.x, velocity.y);
            }
        });
    }

    handlePlayerMovement() {
        let vx = 0;
        let vy = 0;

        if (this.cursors.left.isDown || this.wasd.A.isDown) vx -= 1;
        if (this.cursors.right.isDown || this.wasd.D.isDown) vx += 1;
        if (this.cursors.up.isDown || this.wasd.W.isDown) vy -= 1;
        if (this.cursors.down.isDown || this.wasd.S.isDown) vy += 1;

        if (vx !== 0 || vy !== 0) {
            const norm = Math.sqrt(vx * vx + vy * vy);
            vx = (vx / norm) * CONSTANTS.PLAYER.SPEED;
            vy = (vy / norm) * CONSTANTS.PLAYER.SPEED;
        }

        this.player.setVelocity(vx, vy);
    }

    handleShooting() {
        if (this.time.now > (this.lastShot || 0) + CONSTANTS.PLAYER.SHOOT_DELAY) {
            const closestEnemy = this.findClosestEnemy();
            if (closestEnemy) {
                this.shoot(closestEnemy);
                this.lastShot = this.time.now;
            }
        }
    }

    moveToPointer(pointer) {
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            pointer.worldX, pointer.worldY
        );
        const velocity = this.physics.velocityFromRotation(angle, CONSTANTS.PLAYER.SPEED);
        this.player.setVelocity(velocity.x, velocity.y);
    }

    shoot(target) {
        const projectile = this.projectiles.create(this.player.x, this.player.y, 'projectile');
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            target.x, target.y
        );
        const velocity = this.physics.velocityFromRotation(angle, 300);
        projectile.setVelocity(velocity.x, velocity.y);

        this.time.delayedCall(2000, () => {
            if (projectile.active) {
                projectile.destroy();
            }
        });
    }

    spawnEnemy() {
        if (this.gameState !== GameState.RUNNING || 
            this.enemies.getLength() >= CONSTANTS.GAME.MAX_ENEMIES) {
            return;
        }
        if (this.enemies.getLength() >= CONSTANTS.GAME.MAX_ENEMIES) {
            return;
        }

        const distance = 400;
        const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);
        const x = this.player.x + Math.cos(angle) * distance;
        const y = this.player.y + Math.sin(angle) * distance;
        
        let enemyType;
        const roll = Math.random();
        if (roll < 0.1 && this.level >= 5) {
            enemyType = 'TANK';
        } else if (roll < 0.4 && this.level >= 3) {
            enemyType = 'FAST';
        } else {
            enemyType = 'BASIC';
        }
        
        const enemyConfig = CONSTANTS.ENEMY[enemyType];
        const enemy = this.enemies.create(x, y, `enemy_${enemyType.toLowerCase()}`);
        enemy.setData({
            type: enemyType,
            health: enemyConfig.HEALTH,
            maxHealth: enemyConfig.HEALTH,
            speed: enemyConfig.SPEED,
            damage: enemyConfig.DAMAGE
        });
        
        enemy.healthBar = this.add.rectangle(
            enemy.x,
            enemy.y - 20,
            30,
            4,
            0x00ff00
        );
        
        return enemy;
    }

    findClosestEnemy() {
        let closest = null;
        let minDistance = Infinity;

        this.enemies.getChildren().forEach(enemy => {
            const distance = Phaser.Math.Distance.Between(
                this.player.x, this.player.y,
                enemy.x, enemy.y
            );
            if (distance < minDistance) {
                minDistance = distance;
                closest = enemy;
            }
        });

        return closest;
    }

    hitEnemy(projectile, enemy) {
        if (projectile.active) projectile.destroy();
        
        const damage = this.player.damage;
        enemy.setData('health', enemy.getData('health') - damage);
        
        // Visual feedback
        enemy.setTint(0xff0000);
        this.time.delayedCall(100, () => {
            if (enemy.active) enemy.clearTint();
        });
        
        if (enemy.getData('health') <= 0) {
            const xpValue = enemy.getData('type') === 'TANK' ? 20 :
                          enemy.getData('type') === 'FAST' ? 10 : 5;
            
            const xpOrb = this.xpOrbs.create(enemy.x, enemy.y, 'xp_orb');
            xpOrb.setData('value', xpValue);
            
            if (enemy.healthBar) enemy.healthBar.destroy();
            enemy.destroy();
            
            this.score += xpValue;
        }
    }

    damagePlayer(player, enemy) {
        const damage = enemy.getData('damage');
        player.health -= damage;
        
        // Visual feedback
        player.setTint(0xff0000);
        this.time.delayedCall(100, () => {
            if (player.active) player.clearTint();
        });
        
        if (enemy.healthBar) enemy.healthBar.destroy();
        enemy.destroy();
        
        this.updateHUD();
        
        if (player.health <= 0) {
            this.gameOver();
        }
    }

    collectXP(player, xpOrb) {
        const value = xpOrb.getData('value');
        this.experience += value;
        xpOrb.destroy();
        
        if (this.experience >= this.nextLevelExp) {
            this.levelUp();
        }
        
        this.updateHUD();
    }

    showUpgradeMenu() {
        this.gameState = GameState.LEVELUP;
        this.upgradeMenu.style.display = 'block';
        
        // Get available upgrades
        const availableUpgrades = Object.entries(CONSTANTS.UPGRADES)
            .filter(([key, upgrade]) => this.upgradeLevels[key] < upgrade.maxLevel)
            .sort(() => Math.random() - 0.5)
            .slice(0, 3);

        // Create upgrade options
        this.upgradeMenu.innerHTML = `
            <h2 style="text-align: center; color: #ffff00; margin-bottom: 20px">Level Up!</h2>
            <div style="display: flex; flex-direction: column; gap: 10px;">
                ${availableUpgrades.map(([key, upgrade]) => `
                    <div class="upgrade-option" 
                         style="padding: 10px; border: 1px solid #666; border-radius: 5px; cursor: pointer;"
                         onmouseover="this.style.backgroundColor='rgba(255,255,255,0.1)'"
                         onmouseout="this.style.backgroundColor='transparent'"
                         data-upgrade="${key}">
                        <h3 style="margin: 0; color: #00ff00">${upgrade.name}</h3>
                        <p style="margin: 5px 0; color: #aaa">${upgrade.description}</p>
                        <small style="color: #666">Level ${this.upgradeLevels[key]}/${upgrade.maxLevel}</small>
                    </div>
                `).join('')}
            </div>
        `;

        // Add click handlers
        this.upgradeMenu.querySelectorAll('.upgrade-option').forEach(option => {
            option.addEventListener('click', () => this.selectUpgrade(option.dataset.upgrade));
        });
    }

    selectUpgrade(upgradeKey) {
        const upgrade = CONSTANTS.UPGRADES[upgradeKey];
        this.upgradeLevels[upgradeKey]++;
        upgrade.effect(this.player);
        
        this.upgradeMenu.style.display = 'none';
        this.gameState = GameState.RUNNING;
        
        this.showToast(`Upgraded ${upgrade.name}!`);
    }

    showToast(message) {
        const toast = document.createElement('div');
        toast.style.cssText = `
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            animation: fadeOut 2s forwards;
            z-index: 1000;
        `;
        toast.textContent = message;
        document.body.appendChild(toast);
        
        setTimeout(() => toast.remove(), 2000);
    }

    levelUp() {
        this.level++;
        this.experience -= this.nextLevelExp;
        this.nextLevelExp = Math.floor(this.nextLevelExp * 1.2);
        
        this.showUpgradeMenu();
        
        // Increase player stats
        this.player.damage += 2;
        this.player.maxHealth += 10;
        this.player.health = this.player.maxHealth;
        
        // Visual feedback
        this.add.text(this.player.x, this.player.y - 50, 'LEVEL UP!', {
            fontSize: '24px',
            fill: '#ffff00'
        }).setOrigin(0.5).setDepth(1);
    }

    cleanup() {
        // Clean up all game objects and event listeners
        this.enemies.getChildren().forEach(enemy => {
            if (enemy.healthBar) enemy.healthBar.destroy();
            enemy.destroy();
        });
        this.projectiles.getChildren().forEach(proj => proj.destroy());
        this.xpOrbs.getChildren().forEach(orb => orb.destroy());
        
        // Clear timers
        this.time.removeAllEvents();
        
        // Remove UI elements
        this.upgradeMenu.remove();
        this.tooltip.remove();
    }

    gameOver() {
        this.gameState = GameState.GAMEOVER;
        this.cleanup();
        this.add.text(400, 300, 'GAME OVER\nClick to restart', {
            fontSize: '48px',
            fill: '#ff0000',
            align: 'center'
        }).setOrigin(0.5).setScrollFactor(0);
        
        this.input.once('pointerdown', () => {
            this.scene.restart();
        });
    }

    increaseDifficulty() {
        Object.values(CONSTANTS.ENEMY).forEach(type => {
            type.HEALTH *= 1.1;
            type.DAMAGE *= 1.05;
        });
        if (this.spawnTimer.delay > 200) {
            this.spawnTimer.delay *= 0.9;
        }
    }

    updateHUD() {
        document.getElementById('hud').innerHTML = `
            Level: ${this.level} | Score: ${this.score}<br>
            Health: ${Math.ceil(this.player.health)}/${this.player.maxHealth}<br>
            Experience: ${this.experience}/${this.nextLevelExp}<br>
            Damage: ${this.player.damage}
        `;
    }
}

// Game configuration
const config = {
    type: Phaser.AUTO,
    parent: 'game',
    width: window.innerWidth,
    height: window.innerHeight,
    physics: {
        default: 'arcade',
        arcade: {
            debug: false
        }
    },
    scene: MainScene,
    scale: {
        mode: Phaser.Scale.RESIZE,
        autoCenter: Phaser.Scale.CENTER_BOTH
    }
};

// Start the game
const game = new Phaser.Game(config);

// Handle window resizing
window.addEventListener('resize', () => {
    game.scale.resize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
